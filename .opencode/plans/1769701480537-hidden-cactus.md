# Firestore -> SQLite Migration Review + Hardening Plan

## Goal
- Keep Firebase Auth for login/ID tokens.
- Move app data (exercises/templates, routines, sessions, logs) to SQLite served by `herculito-push-api`.
- Unify exercises globally via canonical IDs (e.g. `mw:<slug>`), preserving history.
- Close security gaps, fix regressions (offline, resume, multi-device freshness), and stabilize the API contract.

## Current State (as implemented)
Backend (`/Users/xlz/Documents/Code/herculito-push-api`)
- SQLite schema is created in `src/db.ts` and now includes app tables (exercises, routines, sessions, logs, aliases).
- Data access layer in `src/data.ts`.
- HTTP endpoints in `src/index.ts` under `/v1/data/*`.
- Migration tooling:
  - Export from Firestore: `scripts/export-firestore.ts`.
  - Import JSON into SQLite: `scripts/migrate-from-json.ts`.

Frontend (`/Users/xlz/Documents/Code/herculito`)
- Firestore hooks replaced with fetch-based API hooks:
  - `src/hooks/useExerciseTemplates.ts`
  - `src/hooks/useRoutines.ts`
  - `src/hooks/useWorkoutSessions.ts`
  - `src/hooks/useWorkouts.ts`
- API client in `src/utils/dataApi.ts` using Firebase ID token.

## Findings (what’s missing / should be improved)

### A) Security / authorization (high priority)
1) Exercises can be modified globally by non-owners
   - `updateExercise()` in `herculito-push-api/src/data.ts` updates the `exercises` row without checking `created_by_uid`.
   - This allows any authenticated user to rename/mutate shared exercises.

2) Workouts endpoint is effectively global (cross-user leak)
   - `workouts` table in `herculito-push-api/src/db.ts` has no `uid`.
   - `listWorkouts()` returns all workouts and `upsertWorkout()` overwrites globally.
   - Even though auth is required, different users can read/overwrite each other.

3) Logs and sessions accept unvalidated nested payloads
   - `exercise_logs.payload_json` and `workout_sessions.exercises_json` accept arbitrary arrays/objects.
   - Risk: oversized payloads, malformed types (Dates serialized as strings), and inconsistent storage.

### B) Data correctness regressions (high priority)
1) No server read path for exercise logs
   - Only `POST /v1/data/exercise-logs` exists; frontend cannot load logs for a date.
   - Current UI relies on local state/localStorage and last session, so refresh/new device loses data.

2) Workout progress not persisted mid-session
   - Frontend defines `updateSessionProgress()` but `src/components/ActiveWorkout.tsx` never calls it.
   - If the app crashes or the user refreshes mid-workout, backend state won’t reflect progress.

3) Date handling is fragile
   - Frontend `toDate()` mappers only handle `number|Date`; API payloads can contain ISO strings (from JSON serialization of `Date`).
   - Some mappers fall back to `new Date()` on unexpected values, silently corrupting ordering.

4) Routine items cannot include the same exercise twice
   - Routine exercises now use canonical `exercise.id` as identity.
   - This prevents a routine from containing repeated entries of the same exercise (and would collide logs/UI).
- Current mitigation blocks duplicates in `src/components/RoutineEditor.tsx`, but this is a UX limitation.

### D) Post-migration issues reported (prod)
1) "Rutinas por defecto" aparecen a todos y no se pueden eliminar
   - Frontend actualmente auto-seedea rutinas y ejercicios cuando no detecta rutinas del usuario:
     - `src/hooks/useRoutines.ts` llama `initializeDefaultRoutines()`.
     - `initializeDefaultRoutines()` crea rutinas con `createdByName: 'Sistema'`.
   - Si estas rutinas quedan sin owner valido (`createdBy/userId`), la UI no muestra botones de editar/eliminar.
   - Ademas, `getPublicRoutines()` incluye rutinas publicas sin owner (ownerless), lo que hace que rutinas "system" se filtren como comunidad.

2) Historial/calendario no muestra sesiones migradas
   - `WorkoutCalendar` y stats filtran por `session.completedAt`.
   - En el `firestore-export.json` los timestamps vienen como `{ "_seconds": ..., "_nanoseconds": ... }`.
   - El migrador `scripts/migrate-from-json.ts` usa `parseDateMs()` que solo contempla `seconds`/`nanoseconds` (sin underscore), por lo que `completedAt` termina en `NULL` al importar.
   - Resultado: sesiones importadas quedan "incompletas" y no aparecen en calendario/historial.

3) Rutinas "publicas del sistema" no deben existir
   - Requisito: solo deben aparecer rutinas creadas/compartidas por usuarios.
   - Accion: deshabilitar seeding y filtrar/eliminar rutinas system/ownerless.

### C) Operational / tooling gaps (medium)
1) `serviceAccount.json` handling
   - The export script looks for `serviceAccount.json` at repo root (by design).
   - We should ensure it is ignored by git and docker build context to prevent accidental leakage.

2) Docker image includes export dependencies
   - `firebase-admin` is only needed for export tooling (local), not production runtime.
   - Current Dockerfile runs `bun install` before `NODE_ENV=production`, so dev dependencies end up in the production image.

## Recommended Approach (implementation plan)

### 1) Lock an explicit API wire format
- Decision: keep epoch milliseconds (`number`) for timestamps in API responses (already used) and accept both `number` and ISO strings in requests.
- Add strict parsing/normalization at backend boundaries for:
  - `WorkoutSet.completedAt` (accept ISO or number; store as number or strip).

Files
- Backend: `herculito-push-api/src/index.ts` (request validation), `herculito-push-api/src/data.ts` (normalization helpers)
- Frontend: `src/hooks/*` mappers (`toDate`) should accept ISO strings and reject invalid values explicitly.

### 2) Fix authorization and scoping
2.1 Exercises
- Split “global exercise fields” vs “user defaults” behavior:
  - Only owner (or admin) can update `exercises.name/category/description/video/is_public`.
  - Any user can update their own `user_exercise_defaults` (sets/reps/restTime/notes/display_name).
- Add owner check in `updateExercise()` (or new endpoint).

2.2 Workouts (legacy weekly plan)

- Decision (user): keep it per-user.
- Add `uid` to `workouts` table and scope reads/writes by token user.

Files
- Backend: `herculito-push-api/src/db.ts`, `herculito-push-api/src/data.ts`, `herculito-push-api/src/index.ts`
- Frontend: `src/hooks/useWorkouts.ts` if workouts are removed or made per-user.

### 3) Add missing read APIs for logs (and optionally sessions)
- Add endpoints:
  - `GET /v1/data/exercise-logs?date=YYYY-MM-DD` (minimum viable)
  - Optionally: range query for calendar/history.
- Frontend: update `useExerciseLogs()` to fetch existing logs on mount/date change and merge with local optimistic edits.

Files
- Backend: `herculito-push-api/src/index.ts`, `herculito-push-api/src/data.ts`
- Frontend: `src/utils/dataApi.ts`, `src/hooks/useWorkouts.ts`

### 4) Persist session progress during workout
- In `src/components/ActiveWorkout.tsx`:
  - debounce `updateSessionProgress(session.id, exerciseLogs)` when logs change and workout is active.
  - flush on `visibilitychange` and when navigating back.

Files
- Frontend: `src/components/ActiveWorkout.tsx`, `src/hooks/useWorkoutSessions.ts`
- Backend: keep `POST /v1/data/sessions/progress` but validate payload size and sanitize nested dates.

### 5) Offline safety (minimum viable)

- Decision (user): medium priority.
- Minimum viable changes:
  - Do not delete queued writes until ACK.
  - Persist pending queue to localStorage (IndexedDB optional later).
  - Retry on `online` event and on app start.

Files
- Frontend: `src/hooks/useWorkouts.ts` (pending writes queue)

### 6) Routine duplicates (optional, but clarifies the model)

- Decision (user): do NOT allow duplicates in routines.
- Keep the current “no duplicates” guard and document the behavior.

Files
- Frontend: `src/types/index.ts`, `src/components/RoutineEditor.tsx`, `src/components/ActiveWorkout.tsx`
- Backend: `herculito-push-api/src/db.ts`, `herculito-push-api/src/data.ts`, `herculito-push-api/src/index.ts`

### 7) Tooling hardening
- Add `serviceAccount.json` to:
  - backend repo `.gitignore`
  - backend repo `.dockerignore`
- Optional: keep export tooling outside production image (set `NODE_ENV=production` before install, or split a separate tooling image).

Files
- Backend: `herculito-push-api/.dockerignore`, `herculito-push-api/.gitignore`, `herculito-push-api/Dockerfile`

## Verification / Test Plan

Backend
- Smoke:
  - `GET /health` returns ok.
  - `/v1/data/*` endpoints reject missing/invalid auth.
- Security:
  - user A cannot update/delete user B routines.
  - user A cannot rename shared global exercises.
  - `/v1/data/workouts` cannot leak/collide between users.
- Data:
  - Create exercise -> fetch exercises -> update defaults -> verify only defaults changed.
  - Create routine -> fetch routines -> update -> delete.
  - Start session -> progress updates -> complete -> list sessions includes exercise data.
  - Logs: write log -> read log(s) for date -> refresh client -> still present.

Frontend
- Create exercise with MuscleWiki video; ensure it appears for other user.
- Create routine, start workout, set weights, refresh mid-workout:
  - progress is recovered (from backend progress and/or localStorage).
- Offline toggle (DevTools): set a weight while offline, reconnect:
  - queued mutation retries and persists.

## Post-migration Fix Plan (specific)

1) Fix timestamp parsing in migrator and re-run import
- Update `herculito-push-api/scripts/migrate-from-json.ts`:
  - `parseDateMs()` must accept Firestore Timestamp JSON with `_seconds`/`_nanoseconds`.
- Re-run the migrator against the SAME production SQLite file.
- Expected outcome: `completedAt` is populated for completed sessions, and calendar/history re-appears.

2) Remove default seeding from frontend
- Remove/disable:
  - `initializeDefaultRoutines()` invocation in `src/hooks/useRoutines.ts`.
  - `initializeBasicExercises()` invocation in `src/hooks/useExerciseTemplates.ts`.
  - default weekly workouts seeding in `src/hooks/useWorkouts.ts` (same principle).
- Expected outcome: new users start empty; no "Sistema" entities are created.

3) Tighten "Public" routines criteria
- Update `getPublicRoutines()` in `src/hooks/useRoutines.ts` to:
  - require a valid owner (`createdBy` or legacy `userId`),
  - exclude ownerless docs,
  - exclude `createdBy === 'system'` (defensive).

4) Cleanup: remove system/ownerless routines/templates from SQLite
- Decision (user): cleanup only system/ownerless.
- Add a one-off cleanup script in `herculito-push-api/scripts/cleanup-system-data.ts` that deletes:
  - routines where `owner_uid = 'system'` (and their `routine_exercises`),
  - exercises where `created_by_uid = 'system'` (and their `user_exercise_defaults`/aliases).
- Run it once on production DB.

## New Findings (from firestore-export.json)
- Export contains:
  - `routines`: 8 total, all `isPublic: true`
  - `createdByName`: only `Larry Ramirez` (5) and `Usuario` (3); no `Sistema`
  - `workoutSessions`: 194; many timestamps stored as `{ "_seconds": ..., "_nanoseconds": ... }`
- Therefore, "Sistema" routines appearing in prod are not coming from this export; they were created after migration (likely seeding from stale PWA, or a system UID not equal to literal `system`).

## Additional Fixes Needed (based on user report)

5) Stop creating public routines by default
- Backend: change `createRoutine` default to private unless `isPublic === true`.
- Frontend: ensure the UI explicitly controls `isPublic` and defaults to private.

6) Remove/Hide low-quality community routines
- Community/public listing should exclude routines where `createdByName` is missing or generic (`Sistema`, `Usuario`).
- Implement server-side filtering for public routines (so it applies regardless of client version).
- Decision (user): hard delete those routines, even if user-owned.
- Add a cleanup script to delete routines where `created_by_name IN ('Sistema','Usuario')` AND `is_public = 1` (and their `routine_exercises`).

7) Fix backend routine listing semantics
- Change `listRoutines` query to return:
  - owned routines: `owner_uid = uid` (always)
  - community routines: `is_public = 1` AND `owner_uid != uid` AND `created_by_name NOT IN ('Sistema','Usuario')`
  - exclude `owner_uid = 'system'` regardless.
- This makes public tab stable even if the client filter changes.

9) Make calendar/history reappear (workoutSessions)
- Root cause candidates:
  - `completed_at_ms` imported as NULL due to Firestore timestamp shape `_seconds/_nanoseconds`.
  - UID mismatch (exported `workoutSessions.userId` != current Firebase uid).
  - `completed_at_ms` stored as TEXT.
- Fix:
  - Update migrator `parseDateMs()` to accept `_seconds/_nanoseconds` and numeric strings.
  - Re-run migrator (idempotent upsert) against prod DB.
  - Add a diagnostic script to print counts of `workout_sessions` by uid and how many have `completed_at_ms IS NOT NULL`.

10) Recover missing community routines
- The Firestore export currently includes only 8 routines total; if you previously had more public routines, the export likely came from:
  - the wrong Firebase project, or
  - data lives in another collection (e.g. `userRoutines` saved/adopted routines), or
  - routines were never in Firestore `routines` (older schema).
- Actions:
  - Re-export including `userRoutines` and validate counts.
  - If needed, re-export from the correct Firebase project (verify `project_id` in serviceAccount.json).
  - Extend migrator to import `userRoutines` into a new SQLite table (or clone into owned routines) so adopted public routines appear.

## Decisions captured
- Public junk cleanup: delete public routines where `created_by_name IN ('Sistema','Usuario')` even if owned by real users.
- Firebase project: confirmed export used correct project.

## Immediate Diagnostics (run on server)

Your host is ARM64, so use an ARM64-friendly container and install sqlite3 on the fly:

1) Sessions by uid and completed count
```bash
docker run --rm -v herculito_push_data:/data alpine:3.20 sh -lc \
  "apk add --no-cache sqlite >/dev/null && sqlite3 /data/push.sqlite \"select uid, count(*) as sessions, sum(completed_at_ms is not null) as completed from workout_sessions group by uid order by sessions desc limit 15;\""
```

2) Sample sessions (check completed_at_ms type)
```bash
docker run --rm -v herculito_push_data:/data alpine:3.20 sh -lc \
  "apk add --no-cache sqlite >/dev/null && sqlite3 /data/push.sqlite \"select id, uid, started_at_ms, completed_at_ms, typeof(completed_at_ms) from workout_sessions where completed_at_ms is not null limit 20;\""
```

3) Public routines inventory (find remaining junk)
```bash
docker run --rm -v herculito_push_data:/data alpine:3.20 sh -lc \
  "apk add --no-cache sqlite >/dev/null && sqlite3 /data/push.sqlite \"select id, owner_uid, is_public, quote(created_by_name) as created_by_name, hex(created_by_name) as hex_name, quote(name) as name, hex(name) as hex_routine_name from routines where is_public=1 order by created_by_name limit 80;\""
```

These outputs determine whether the issue is: (a) uid mismatch, (b) completed_at_ms not populated, or (c) created_by_name contains hidden characters.

## Planned code changes (next iteration)

### A) Robust cleanup + filtering of junk authors
- Normalize `created_by_name` on the server side for filtering and cleanup:
  - Use `lower(trim(replace(created_by_name, char(160), ' ')))` to handle NBSP.
  - Treat any of these as junk: `sistema`, `usuario`.
- Apply the same normalization in:
  - `herculito-push-api/src/data.ts` listRoutines (public listing)
  - `herculito-push-api/scripts/cleanup-system-data.ts`

### B) Fix empty calendar even if completedAt missing
- Decision (user): backfill by evidence.
- Add a one-off backfill script (or extend migrator) to derive `completed_at_ms` for sessions where it is NULL only when evidence exists:
  - If `total_duration_min` exists and > 0: `completed_at_ms = started_at_ms + total_duration_min*60*1000`
  - Else if `exercises_json` contains sets with `completedAt` timestamps: use max timestamp
  - Else if there is at least one `exercise_logs` row for the same `(uid, date)` where `date` matches the session's started date (UTC): set `completed_at_ms = started_at_ms`
- After backfill, calendar/stats should reflect historical days.

### C) Re-export + migrate missing collections
- Re-run export with updated defaults to include:
  - `exerciseHistory`, `userRoutines`, `workouts`
- Then extend migrator to import:
  - `exerciseHistory` -> seed `exercise_logs` (or new table) so progress exists
  - `userRoutines` -> determine whether these docs are full routines or mapping; import accordingly

## Notes on firestore-export.json size
- El archivo puede tener ~20k lineas aunque haya pocas rutinas porque cada template incluye `video.variants` (muchas URLs) y los logs/sesiones contienen arrays grandes.
- El JSON actual solo contiene 4 keys top-level: `exerciseTemplates`, `routines`, `workoutSessions`, `exerciseLogs`.
- No incluye `exerciseHistory`, `userRoutines`, `workouts`, asi que progresiones/guardados que vivian ahi no se migran aun.

## CURRENT ISSUES (Feb 2025) - User Report

### Issue 1: Old public routines not showing in Community tab
**Status:** User confirmed new routines work, but old public routines from other users don't appear.

**Analysis:**
- Firestore export shows only 8 routines total, 3 with `createdByName: "Usuario"`
- Backend SQL currently filters OUT routines where `created_by_name IN ('Sistema', 'Usuario')`  
- This prevents the 3 "Usuario" routines from showing up
- User wants to delete them but can't see them

**Root cause:** The backend filter is too aggressive - it's filtering by display name rather than actual ownership.

### Issue 2: Old historical sessions not appearing in calendar/history  
**Status:** New sessions appear, old migrated sessions don't.

**Analysis:**
- User ran diagnostics: 39 sessions have `completed_at_ms` (integer), 155 have NULL
- The sessions ARE in the database (194 total)
- But only 39 are "completed" from migration
- Old sessions likely have NULL completed_at_ms even if they were finished

**Root cause:** Firestore export has `completedAt` field but migration didn't populate `completed_at_ms` properly, OR old sessions were incomplete in Firestore.

### Solution Strategy

For routines (Issue 1):
1. TEMPORARILY remove the `created_by_name` filter from backend
2. Show ALL public routines so user can see what's there
3. User deletes unwanted ones via UI  
4. Then restore filtering for future (filter by quality, not by generic names)

For sessions (Issue 2):
1. Run backfill script to populate `completed_at_ms` based on evidence:
   - If `total_duration_min > 0` → session was completed
   - If exercises have completed sets → session was completed
   - If exercise_logs exist for that date → session was completed
2. This will make old sessions appear in calendar

### Immediate Next Steps

1. Deploy backend with TEMPORARY filter removal
2. User reviews and deletes unwanted "Usuario" routines  
3. Run backfill-sessions script
4. Verify calendar shows old history
5. Deploy backend with restored (better) filtering

7) Export & import missing Firestore collections
- Re-run export including:
  - `userRoutines`, `exerciseHistory`, `workouts`
- Update migrator to import `exerciseHistory` (and optionally map `userRoutines` depending on how it was used).

## CRITICAL BUG FOUND: Calendar Empty Despite Sessions in DB

**Root cause identified:**
The backend returns `completedAt` as a **number** (timestamp in ms), but the frontend `toDate()` mapper has this logic:
```typescript
if (!value) return undefined;  // LINE 13 - PROBLEM!
if (typeof value === 'number') {
  const ms = value < 1e12 ? value * 1000 : value;
  return new Date(ms);
}
```

**Issues:**
1. If the API returns `completedAt: 0` (rare but possible), it becomes `undefined`
2. If the API returns `completedAt: null` instead of omitting the field, `toDate(null)` returns `undefined`
3. WorkoutCalendar filters out any session with `!completedAt` (line 32)

**But the real issue:** User has 115 sessions with valid `completed_at_ms` in DB (1759086889000, etc.), yet calendar is empty.

**Hypothesis:** The API response format might be wrong. Need to verify actual API response.

**Diagnostic command:**
```bash
# Get your Firebase token from browser console:
# await firebase.auth().currentUser.getIdToken()
# Then run:
curl -s -H "Authorization: Bearer YOUR_TOKEN" \
  https://api.herculito.exloz.site/v1/data/sessions | jq '.sessions[0:3]'
```

This will show if `completedAt` is being returned correctly as a number.

**Immediate fix needed:**
If the API returns `completedAt: null` for completed sessions (instead of the timestamp), the backend SQL query needs to be checked.

8) Production diagnostics checklist (must do before re-running import)
- Confirm which DB file is in use.
- Run quick SQL checks:
  - Count completed sessions for a given uid.
  - Count routines by `created_by_name` and `owner_uid`.
  - Verify `completed_at_ms` is being set after import.
