# Firestore -> SQLite Migration Review + Hardening Plan

## Goal
- Keep Firebase Auth for login/ID tokens.
- Move app data (exercises/templates, routines, sessions, logs) to SQLite served by `herculito-push-api`.
- Unify exercises globally via canonical IDs (e.g. `mw:<slug>`), preserving history.
- Close security gaps, fix regressions (offline, resume, multi-device freshness), and stabilize the API contract.

## Current State (as implemented)
Backend (`/Users/xlz/Documents/Code/herculito-push-api`)
- SQLite schema is created in `src/db.ts` and now includes app tables (exercises, routines, sessions, logs, aliases).
- Data access layer in `src/data.ts`.
- HTTP endpoints in `src/index.ts` under `/v1/data/*`.
- Migration tooling:
  - Export from Firestore: `scripts/export-firestore.ts`.
  - Import JSON into SQLite: `scripts/migrate-from-json.ts`.

Frontend (`/Users/xlz/Documents/Code/herculito`)
- Firestore hooks replaced with fetch-based API hooks:
  - `src/hooks/useExerciseTemplates.ts`
  - `src/hooks/useRoutines.ts`
  - `src/hooks/useWorkoutSessions.ts`
  - `src/hooks/useWorkouts.ts`
- API client in `src/utils/dataApi.ts` using Firebase ID token.

## Findings (what’s missing / should be improved)

### A) Security / authorization (high priority)
1) Exercises can be modified globally by non-owners
   - `updateExercise()` in `herculito-push-api/src/data.ts` updates the `exercises` row without checking `created_by_uid`.
   - This allows any authenticated user to rename/mutate shared exercises.

2) Workouts endpoint is effectively global (cross-user leak)
   - `workouts` table in `herculito-push-api/src/db.ts` has no `uid`.
   - `listWorkouts()` returns all workouts and `upsertWorkout()` overwrites globally.
   - Even though auth is required, different users can read/overwrite each other.

3) Logs and sessions accept unvalidated nested payloads
   - `exercise_logs.payload_json` and `workout_sessions.exercises_json` accept arbitrary arrays/objects.
   - Risk: oversized payloads, malformed types (Dates serialized as strings), and inconsistent storage.

### B) Data correctness regressions (high priority)
1) No server read path for exercise logs
   - Only `POST /v1/data/exercise-logs` exists; frontend cannot load logs for a date.
   - Current UI relies on local state/localStorage and last session, so refresh/new device loses data.

2) Workout progress not persisted mid-session
   - Frontend defines `updateSessionProgress()` but `src/components/ActiveWorkout.tsx` never calls it.
   - If the app crashes or the user refreshes mid-workout, backend state won’t reflect progress.

3) Date handling is fragile
   - Frontend `toDate()` mappers only handle `number|Date`; API payloads can contain ISO strings (from JSON serialization of `Date`).
   - Some mappers fall back to `new Date()` on unexpected values, silently corrupting ordering.

4) Routine items cannot include the same exercise twice
   - Routine exercises now use canonical `exercise.id` as identity.
   - This prevents a routine from containing repeated entries of the same exercise (and would collide logs/UI).
- Current mitigation blocks duplicates in `src/components/RoutineEditor.tsx`, but this is a UX limitation.

### D) Post-migration issues reported (prod)
1) "Rutinas por defecto" aparecen a todos y no se pueden eliminar
   - Frontend actualmente auto-seedea rutinas y ejercicios cuando no detecta rutinas del usuario:
     - `src/hooks/useRoutines.ts` llama `initializeDefaultRoutines()`.
     - `initializeDefaultRoutines()` crea rutinas con `createdByName: 'Sistema'`.
   - Si estas rutinas quedan sin owner valido (`createdBy/userId`), la UI no muestra botones de editar/eliminar.
   - Ademas, `getPublicRoutines()` incluye rutinas publicas sin owner (ownerless), lo que hace que rutinas "system" se filtren como comunidad.

2) Historial/calendario no muestra sesiones migradas
   - `WorkoutCalendar` y stats filtran por `session.completedAt`.
   - En el `firestore-export.json` los timestamps vienen como `{ "_seconds": ..., "_nanoseconds": ... }`.
   - El migrador `scripts/migrate-from-json.ts` usa `parseDateMs()` que solo contempla `seconds`/`nanoseconds` (sin underscore), por lo que `completedAt` termina en `NULL` al importar.
   - Resultado: sesiones importadas quedan "incompletas" y no aparecen en calendario/historial.

3) Rutinas "publicas del sistema" no deben existir
   - Requisito: solo deben aparecer rutinas creadas/compartidas por usuarios.
   - Accion: deshabilitar seeding y filtrar/eliminar rutinas system/ownerless.

### C) Operational / tooling gaps (medium)
1) `serviceAccount.json` handling
   - The export script looks for `serviceAccount.json` at repo root (by design).
   - We should ensure it is ignored by git and docker build context to prevent accidental leakage.

2) Docker image includes export dependencies
   - `firebase-admin` is only needed for export tooling (local), not production runtime.
   - Current Dockerfile runs `bun install` before `NODE_ENV=production`, so dev dependencies end up in the production image.

## Recommended Approach (implementation plan)

### 1) Lock an explicit API wire format
- Decision: keep epoch milliseconds (`number`) for timestamps in API responses (already used) and accept both `number` and ISO strings in requests.
- Add strict parsing/normalization at backend boundaries for:
  - `WorkoutSet.completedAt` (accept ISO or number; store as number or strip).

Files
- Backend: `herculito-push-api/src/index.ts` (request validation), `herculito-push-api/src/data.ts` (normalization helpers)
- Frontend: `src/hooks/*` mappers (`toDate`) should accept ISO strings and reject invalid values explicitly.

### 2) Fix authorization and scoping
2.1 Exercises
- Split “global exercise fields” vs “user defaults” behavior:
  - Only owner (or admin) can update `exercises.name/category/description/video/is_public`.
  - Any user can update their own `user_exercise_defaults` (sets/reps/restTime/notes/display_name).
- Add owner check in `updateExercise()` (or new endpoint).

2.2 Workouts (legacy weekly plan)

- Decision (user): keep it per-user.
- Add `uid` to `workouts` table and scope reads/writes by token user.

Files
- Backend: `herculito-push-api/src/db.ts`, `herculito-push-api/src/data.ts`, `herculito-push-api/src/index.ts`
- Frontend: `src/hooks/useWorkouts.ts` if workouts are removed or made per-user.

### 3) Add missing read APIs for logs (and optionally sessions)
- Add endpoints:
  - `GET /v1/data/exercise-logs?date=YYYY-MM-DD` (minimum viable)
  - Optionally: range query for calendar/history.
- Frontend: update `useExerciseLogs()` to fetch existing logs on mount/date change and merge with local optimistic edits.

Files
- Backend: `herculito-push-api/src/index.ts`, `herculito-push-api/src/data.ts`
- Frontend: `src/utils/dataApi.ts`, `src/hooks/useWorkouts.ts`

### 4) Persist session progress during workout
- In `src/components/ActiveWorkout.tsx`:
  - debounce `updateSessionProgress(session.id, exerciseLogs)` when logs change and workout is active.
  - flush on `visibilitychange` and when navigating back.

Files
- Frontend: `src/components/ActiveWorkout.tsx`, `src/hooks/useWorkoutSessions.ts`
- Backend: keep `POST /v1/data/sessions/progress` but validate payload size and sanitize nested dates.

### 5) Offline safety (minimum viable)

- Decision (user): medium priority.
- Minimum viable changes:
  - Do not delete queued writes until ACK.
  - Persist pending queue to localStorage (IndexedDB optional later).
  - Retry on `online` event and on app start.

Files
- Frontend: `src/hooks/useWorkouts.ts` (pending writes queue)

### 6) Routine duplicates (optional, but clarifies the model)

- Decision (user): do NOT allow duplicates in routines.
- Keep the current “no duplicates” guard and document the behavior.

Files
- Frontend: `src/types/index.ts`, `src/components/RoutineEditor.tsx`, `src/components/ActiveWorkout.tsx`
- Backend: `herculito-push-api/src/db.ts`, `herculito-push-api/src/data.ts`, `herculito-push-api/src/index.ts`

### 7) Tooling hardening
- Add `serviceAccount.json` to:
  - backend repo `.gitignore`
  - backend repo `.dockerignore`
- Optional: keep export tooling outside production image (set `NODE_ENV=production` before install, or split a separate tooling image).

Files
- Backend: `herculito-push-api/.dockerignore`, `herculito-push-api/.gitignore`, `herculito-push-api/Dockerfile`

## Verification / Test Plan

Backend
- Smoke:
  - `GET /health` returns ok.
  - `/v1/data/*` endpoints reject missing/invalid auth.
- Security:
  - user A cannot update/delete user B routines.
  - user A cannot rename shared global exercises.
  - `/v1/data/workouts` cannot leak/collide between users.
- Data:
  - Create exercise -> fetch exercises -> update defaults -> verify only defaults changed.
  - Create routine -> fetch routines -> update -> delete.
  - Start session -> progress updates -> complete -> list sessions includes exercise data.
  - Logs: write log -> read log(s) for date -> refresh client -> still present.

Frontend
- Create exercise with MuscleWiki video; ensure it appears for other user.
- Create routine, start workout, set weights, refresh mid-workout:
  - progress is recovered (from backend progress and/or localStorage).
- Offline toggle (DevTools): set a weight while offline, reconnect:
  - queued mutation retries and persists.

## Post-migration Fix Plan (specific)

1) Fix timestamp parsing in migrator and re-run import
- Update `herculito-push-api/scripts/migrate-from-json.ts`:
  - `parseDateMs()` must accept Firestore Timestamp JSON with `_seconds`/`_nanoseconds`.
- Re-run the migrator against the SAME production SQLite file.
- Expected outcome: `completedAt` is populated for completed sessions, and calendar/history re-appears.

2) Remove default seeding from frontend
- Remove/disable:
  - `initializeDefaultRoutines()` invocation in `src/hooks/useRoutines.ts`.
  - `initializeBasicExercises()` invocation in `src/hooks/useExerciseTemplates.ts`.
  - default weekly workouts seeding in `src/hooks/useWorkouts.ts` (same principle).
- Expected outcome: new users start empty; no "Sistema" entities are created.

3) Tighten "Public" routines criteria
- Update `getPublicRoutines()` in `src/hooks/useRoutines.ts` to:
  - require a valid owner (`createdBy` or legacy `userId`),
  - exclude ownerless docs,
  - exclude `createdBy === 'system'` (defensive).

4) Cleanup: remove system/ownerless routines/templates from SQLite
- Decision (user): cleanup only system/ownerless.
- Add a one-off cleanup script in `herculito-push-api/scripts/cleanup-system-data.ts` that deletes:
  - routines where `owner_uid = 'system'` (and their `routine_exercises`),
  - exercises where `created_by_uid = 'system'` (and their `user_exercise_defaults`/aliases).
- Run it once on production DB.

## New Findings (from firestore-export.json)
- Export contains:
  - `routines`: 8 total, all `isPublic: true`
  - `createdByName`: only `Larry Ramirez` (5) and `Usuario` (3); no `Sistema`
  - `workoutSessions`: 194; many timestamps stored as `{ "_seconds": ..., "_nanoseconds": ... }`
- Therefore, "Sistema" routines appearing in prod are not coming from this export; they were created after migration (likely seeding from stale PWA, or a system UID not equal to literal `system`).

## Additional Fixes Needed (based on user report)

5) Stop creating public routines by default
- Backend: change `createRoutine` default to private unless `isPublic === true`.
- Frontend: ensure the UI explicitly controls `isPublic` and defaults to private.

6) Remove/Hide low-quality community routines
- Community/public listing should exclude routines where `createdByName` is missing or generic (`Sistema`, `Usuario`).
- Implement server-side filtering for public routines (so it applies regardless of client version).
- Decision (user): hard delete those routines, even if user-owned.
- Add a cleanup script to delete routines where `created_by_name IN ('Sistema','Usuario')` AND `is_public = 1` (and their `routine_exercises`).

7) Fix backend routine listing semantics
- Change `listRoutines` query to return:
  - owned routines: `owner_uid = uid` (always)
  - community routines: `is_public = 1` AND `owner_uid != uid` AND `created_by_name NOT IN ('Sistema','Usuario')`
  - exclude `owner_uid = 'system'` regardless.
- This makes public tab stable even if the client filter changes.

9) Make calendar/history reappear (workoutSessions)
- Root cause candidates:
  - `completed_at_ms` imported as NULL due to Firestore timestamp shape `_seconds/_nanoseconds`.
  - UID mismatch (exported `workoutSessions.userId` != current Firebase uid).
  - `completed_at_ms` stored as TEXT.
- Fix:
  - Update migrator `parseDateMs()` to accept `_seconds/_nanoseconds` and numeric strings.
  - Re-run migrator (idempotent upsert) against prod DB.
  - Add a diagnostic script to print counts of `workout_sessions` by uid and how many have `completed_at_ms IS NOT NULL`.

10) Recover missing community routines
- The Firestore export currently includes only 8 routines total; if you previously had more public routines, the export likely came from:
  - the wrong Firebase project, or
  - data lives in another collection (e.g. `userRoutines` saved/adopted routines), or
  - routines were never in Firestore `routines` (older schema).
- Actions:
  - Re-export including `userRoutines` and validate counts.
  - If needed, re-export from the correct Firebase project (verify `project_id` in serviceAccount.json).
  - Extend migrator to import `userRoutines` into a new SQLite table (or clone into owned routines) so adopted public routines appear.

## Decisions captured
- Public junk cleanup: delete public routines where `created_by_name IN ('Sistema','Usuario')` even if owned by real users.
- Firebase project: confirmed export used correct project.

7) Export & import missing Firestore collections
- Re-run export including:
  - `userRoutines`, `exerciseHistory`, `workouts`
- Update migrator to import `exerciseHistory` (and optionally map `userRoutines` depending on how it was used).

8) Production diagnostics checklist (must do before re-running import)
- Confirm which DB file is in use.
- Run quick SQL checks:
  - Count completed sessions for a given uid.
  - Count routines by `created_by_name` and `owner_uid`.
  - Verify `completed_at_ms` is being set after import.
